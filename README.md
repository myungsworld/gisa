# gisa

개념적 설계- 트랜잭션(원자성,고립성(격리성),일관성,지속성)
논리적 설계- DBMS
물리적 설계- 접근 경로,방법,응답시간,저장공간의 효율화

비트맵 인덱스-데이터종류가 적고 동일한 데이터가 많은 경우(분포도가 낮은경우) 최적의 성능을 발휘
인덱스와 테이블 데이터는 분리하여 설계

속성들이 가질수잇는 모든값들의 집합=도메인
같은 개체를 갖는 속성들의 집합=개체

predicate calculus - 관계해석 

테이블스페이스-논리적인 영역
데이터 파일-물리적인 영역

원자성-All of nothing 전부가 아니면 아무것도 아니다

클러스터 -동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법 조회속도 빠르게되지만 입력 수정 삭제는 느리게 됨
        -단일 테이블 클러스터링->처리 범위 넓은경우
        -다중 ->조인이 많은 경우

        
파티션 대용량 테이블,인덱스를 논리적인 단위로 나누는 것
       local partioned index 1:1 대응 이게 데이터 관리 더 쉬움
       global partitioned index 독립적 
       범위 분할->데이터가 집중되는 단점 발생
       해쉬 분할->데이터를 분산하여 분할
분산데이터의 위치 투명성은 독립적이다,
            사이트간의 오류발생률은 높지만 그 기능이 계속 수행될순 있다
            데이터는 일관성있어야 한다 가용성 높여야한다 

접근통제 3요소 - 정보커 (정책,보안모델,메커니즘)
                보안모델-정형모델
                메커니즘-기술적 방법
                정책-신분기반,규칙기반,역할기반
                
보안     인가된 사용자가  접근-> 기밀성
                        수정-> 무결성
                        
데이터베이스 백업 로그파일-시간의흐름에따라 기록한 파일 (작업순서x)

스토리지 -DAS 직접연결되서 속도는 빠르지만 다른서버에서 접근불가
        -NAS 네트워크를 통해 연결 서버들이 자유롭게 접근 서버가 증가하면?
        -SAN 위에둘 짬뽕 파이버채널(FC)하면 SAN

슈퍼타입테이블->하나
서브타입테이블->여러개 1:1관계임 두개
두개가 하나로 통합된 테이블에는 모든 서브타입 속성을 포함해야됨

준거성=표준성

SQL예약어는 될수있으면 컬럼명으로 사용하지 않아야한다.
한개의insert 명령어로는 하나의 테이블만 생성가능
한개의 DELET 문에는 한개의 테이블만 사용가능
SQL에서 조건문= WHERE,LIKE

integer 4바이트 정수
smalliant 2바이트 정수
float 부동 소수점 수
decimal 10진 소수

table의 check절은 인덱스에 대한 정보를 저장

프로시저에서 EXCEPTION은 BEGIN-END 영역안에서 오류발생한 경우 처리

DELETE는 테이블에서 튜플삭제
DROP은 프로시져,트리거
<>은 같지않다를 의미함

트리거의 구문에는 DCL을 사용할수 없다
EVENT 트리거가 실행되는 조건을 명시

프로시저는 IN OUT이 다 있고 사용자 정의 함수는 IN만 있다 IN은 전달받고 OUT은 반환하는것

Dynamic SQL은 SQL을 자유롭게 변경할수 있어 NULL을 처리하는 함수 사용할 필요가 없다
WEB server -> WAS -> DBMS

ORM -재사용과 유지보수가 쉽다 ,객체가 데이터베이스에 독립적,SQL은 학습해야함
